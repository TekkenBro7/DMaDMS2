DROP TABLE C##MYUSER.STUDENTS;
DROP TABLE C##MYUSER.GROUPS;


-- 1. Создание таблиц STUDENTS и GROUPS
CREATE TABLE C##MYUSER.GROUPS (
    ID NUMBER PRIMARY KEY,
    NAME VARCHAR2(100) NOT NULL,
    C_VAL NUMBER DEFAULT 0
);

CREATE TABLE C##MYUSER.STUDENTS (
    ID NUMBER PRIMARY KEY,
    NAME VARCHAR2(100) NOT NULL,
    GROUP_ID NUMBER
);

-- 2. Реализовать триггеры для таблиц задания 1 проверку целостности (проверка
-- на уникальность полей ID), генерацию автоинкрементного ключа и проверку
-- уникальности для поля GROUP.NAME
CREATE OR REPLACE TRIGGER check_unique_group_id
    BEFORE INSERT OR UPDATE
    ON C##MYUSER.GROUPS
    FOR EACH ROW
DECLARE
    count_id NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO count_id
    FROM C##MYUSER.GROUPS
    WHERE ID = :NEW.ID AND ID != NVL(:OLD.ID, -1);

    IF (count_id != 0) THEN
        raise_application_error(-20001, 'Ошибка: Поле ID в таблице GROUPS должно быть уникальным.');
    END IF;
END;
/

SELECT * FROM C##MYUSER.GROUPS;

INSERT INTO C##MYUSER.GROUPS (ID, NAME, C_VAL) VALUES (1, 'Group A', 10);

INSERT INTO C##MYUSER.GROUPS (ID, NAME, C_VAL) VALUES (2, 'Group B', 20);

INSERT INTO C##MYUSER.GROUPS (ID, NAME, C_VAL) VALUES (1, 'Group C', 30);



CREATE OR REPLACE TRIGGER check_unique_student_id
    BEFORE INSERT OR UPDATE
    ON C##MYUSER.STUDENTS
    FOR EACH ROW
DECLARE
    count_id NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO count_id
    FROM C##MYUSER.STUDENTS
    WHERE ID = :NEW.ID AND ID != NVL(:OLD.ID, -1);

    IF (count_id != 0) THEN
        RAISE_APPLICATION_ERROR(-20002, 'Ошибка: Поле ID в таблице STUDENTS должно быть уникальным.');
    END IF;
END;
/

SELECT * FROM C##MYUSER.STUDENTS;

INSERT INTO C##MYUSER.STUDENTS (ID, NAME, GROUP_ID) VALUES (1, 'Student A', 1);
INSERT INTO C##MYUSER.STUDENTS (ID, NAME, GROUP_ID) VALUES (2, 'Student B', 1);

INSERT INTO C##MYUSER.STUDENTS (ID, NAME, GROUP_ID) VALUES (1, 'Student C', 2);

CREATE SEQUENCE C##MYUSER.GROUPS_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE;

CREATE OR REPLACE TRIGGER group_autoincrement_id
BEFORE INSERT ON C##MYUSER.GROUPS
FOR EACH ROW
BEGIN
  IF :NEW.ID IS NULL THEN
    SELECT C##MYUSER.GROUPS_SEQ.NEXTVAL INTO :NEW.ID FROM dual;
  END IF;
END;
/

SELECT * FROM C##MYUSER.GROUPS;

INSERT INTO C##MYUSER.GROUPS (ID, NAME, C_VAL) VALUES (NULL, 'Group C', 10);
INSERT INTO C##MYUSER.GROUPS (NAME, C_VAL) VALUES ('Group D', 20);
INSERT INTO C##MYUSER.GROUPS (NAME, C_VAL) VALUES ('Group E', 30);

DELETE FROM C##MYUSER.GROUPS WHERE ID = 5;

CREATE SEQUENCE C##MYUSER.STUDENTS_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE;

CREATE OR REPLACE TRIGGER students_autoincrement_id
BEFORE INSERT ON C##MYUSER.STUDENTS
FOR EACH ROW
BEGIN
  IF :NEW.ID IS NULL THEN
    SELECT C##MYUSER.STUDENTS_SEQ.NEXTVAL INTO :NEW.ID FROM dual;
  END IF;
END;
/

SELECT * FROM C##MYUSER.STUDENTS;

INSERT INTO C##MYUSER.STUDENTS (NAME, GROUP_ID) VALUES ('Student C', 2);
INSERT INTO C##MYUSER.STUDENTS (ID, NAME, GROUP_ID) VALUES (NULL, 'Student D', 2);

DELETE FROM C##MYUSER.STUDENTS WHERE ID = 3;

INSERT INTO C##MYUSER.STUDENTS (ID, NAME, GROUP_ID) VALUES (5, 'Student E', 2);

CREATE OR REPLACE TRIGGER check_unique_group_name
    BEFORE INSERT OR UPDATE
    ON C##MYUSER.GROUPS
    FOR EACH ROW
DECLARE
    count_name NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO count_name
    FROM C##MYUSER.GROUPS
    WHERE NAME = :NEW.NAME AND ID != :NEW.ID;

    IF (count_name != 0) THEN
        RAISE_APPLICATION_ERROR(-20003, 'Ошибка: Поле NAME в таблице GROUPS должно быть уникальным.');
    END IF;
END;
/

SELECT * FROM C##MYUSER.GROUPS;

INSERT INTO C##MYUSER.GROUPS (NAME, C_VAL) VALUES ('Group B', 10);





-- 3. Триггер для каскадного удаления STUDENTS при удалении GROUPS
CREATE OR REPLACE TRIGGER trg_students_control
BEFORE INSERT OR DELETE OR UPDATE ON C##MYUSER.GROUPS
FOR EACH ROW
DECLARE
    v_group_exists NUMBER;
BEGIN
    IF INSERTING THEN
        SELECT COUNT(*) INTO v_group_exists FROM C##MYUSER.GROUPS WHERE ID = :NEW.ID;
        IF v_group_exists <> 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'Группа с таким ID существует.');
        END IF;
    END IF;

    IF DELETING THEN
        DELETE FROM C##MYUSER.STUDENTS WHERE GROUP_ID = :OLD.ID;
    END IF;

    IF UPDATING AND :NEW.ID <> :OLD.ID THEN
        UPDATE C##MYUSER.STUDENTS 
        SET GROUP_ID = :NEW.ID 
        WHERE GROUP_ID = :OLD.ID;
    END IF;
END;
/

CREATE OR REPLACE TRIGGER trg_students_group_check
BEFORE INSERT OR UPDATE ON C##MYUSER.STUDENTS
FOR EACH ROW
DECLARE
    v_group_exists NUMBER;
BEGIN
    IF INSERTING OR (UPDATING AND :NEW.GROUP_ID IS NOT NULL AND :NEW.GROUP_ID <> :OLD.GROUP_ID) THEN
        SELECT COUNT(*) INTO v_group_exists FROM C##MYUSER.GROUPS WHERE ID = :NEW.GROUP_ID;
        IF v_group_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20010, 'Ошибка: Группа с таким ID не существует.');
        END IF;
    END IF;
END;
/

INSERT INTO C##MYUSER.GROUPS (NAME, C_VAL) VALUES ('Group C', 10);
INSERT INTO C##MYUSER.GROUPS (NAME, C_VAL) VALUES ('Group D', 20);


DELETE FROM C##MYUSER.GROUPS WHERE ID = 1;

SELECT * FROM c##myuser.GROUPS;

INSERT INTO C##MYUSER.STUDENTS (NAME, GROUP_ID) VALUES ('Student 2', 5);
INSERT INTO C##MYUSER.STUDENTS (ID, NAME, GROUP_ID) VALUES (NULL, 'Student D', 2);

UPDATE C##MYUSER.STUDENTS
SET NAME = 'Updated Student D', GROUP_ID = 5
WHERE ID = 5;


SELECT * FROM c##myuser.STUDENTS;



-- 4. Триггер для журналирования действий в STUDENTS
DROP TABLE C##MYUSER.STUDENTS_LOG;

CREATE TABLE C##MYUSER.STUDENTS_LOG (
    LOG_ID NUMBER PRIMARY KEY,
    OPERATION VARCHAR2(50),
    STUDENT_ID NUMBER,
    STUDENT_NAME VARCHAR2(100),
    GROUP_ID NUMBER,
    TIMESTAMP DATE DEFAULT SYSDATE
);

CREATE OR REPLACE TRIGGER student_log_trigger
AFTER INSERT OR UPDATE OR DELETE ON C##MYUSER.STUDENTS
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO C##MYUSER.STUDENTS_LOG (LOG_ID, OPERATION, STUDENT_ID, STUDENT_NAME, GROUP_ID)
        VALUES ((SELECT NVL(MAX(LOG_ID), 0) + 1 FROM C##MYUSER.STUDENTS_LOG), 'INSERT', :NEW.ID, :NEW.NAME, :NEW.GROUP_ID);
    ELSIF UPDATING THEN
        INSERT INTO C##MYUSER.STUDENTS_LOG (LOG_ID, OPERATION, STUDENT_ID, STUDENT_NAME, GROUP_ID)
        VALUES ((SELECT NVL(MAX(LOG_ID), 0) + 1 FROM C##MYUSER.STUDENTS_LOG), 'UPDATE', :OLD.ID, :OLD.NAME, :OLD.GROUP_ID);
    ELSIF DELETING THEN
        INSERT INTO C##MYUSER.STUDENTS_LOG (LOG_ID, OPERATION, STUDENT_ID, STUDENT_NAME, GROUP_ID)
        VALUES ((SELECT NVL(MAX(LOG_ID), 0) + 1 FROM C##MYUSER.STUDENTS_LOG), 'DELETE', :OLD.ID, :OLD.NAME, :OLD.GROUP_ID);
    END IF;
END;
/


SELECT * FROM C##MYUSER.STUDENTS;
SELECT * FROM C##MYUSER.GROUPS;

SELECT * FROM C##MYUSER.STUDENTS_LOG;

DELETE FROM C##MYUSER.STUDENTS_LOG WHERE LOG_ID = 4;

INSERT INTO C##MYUSER.STUDENTS (NAME, GROUP_ID) VALUES ('Student C', 2);
INSERT INTO C##MYUSER.STUDENTS (NAME, GROUP_ID) VALUES ('Student D', 4);

INSERT INTO C##MYUSER.STUDENTS (NAME, GROUP_ID) VALUES ('Student 12', 2);
INSERT INTO C##MYUSER.STUDENTS (NAME, GROUP_ID) VALUES ('Student 13', 5);

DELETE FROM C##MYUSER.STUDENTS WHERE ID = 8;

UPDATE C##MYUSER.STUDENTS
SET NAME = 'Updated', GROUP_ID = 3
WHERE ID = 7;

-- 5. Процедура восстановления данных
CREATE OR REPLACE PROCEDURE RestoreStudents(
    p_date IN DATE DEFAULT NULL,  
    p_offset IN NUMBER DEFAULT NULL
) IS
    v_target_date DATE;
BEGIN
    IF p_date IS NOT NULL THEN
        v_target_date := p_date; 
    ELSIF p_offset IS NOT NULL THEN
        v_target_date := SYSDATE - (p_offset / 1440); 
    ELSE
        RAISE_APPLICATION_ERROR(-20004, 'Необходимо указать либо временной момент, либо временное смещение');
    END IF;

    FOR rec IN (
        SELECT * 
        FROM C##MYUSER.STUDENTS_LOG 
        WHERE TIMESTAMP >= v_target_date 
        ORDER BY TIMESTAMP DESC
    ) LOOP
        IF rec.OPERATION = 'INSERT' THEN
            DELETE FROM C##MYUSER.STUDENTS WHERE ID = rec.STUDENT_ID;
        ELSIF rec.OPERATION = 'UPDATE' THEN
            UPDATE C##MYUSER.STUDENTS
            SET NAME = rec.STUDENT_NAME, GROUP_ID = rec.GROUP_ID
            WHERE ID = rec.STUDENT_ID;
        ELSIF rec.OPERATION = 'DELETE' THEN
            INSERT INTO C##MYUSER.STUDENTS (ID, NAME, GROUP_ID)
            VALUES (rec.STUDENT_ID, rec.STUDENT_NAME, rec.GROUP_ID);
        END IF;
    END LOOP;
    COMMIT;
END;
/


INSERT INTO C##MYUSER.STUDENTS (NAME, GROUP_ID) VALUES ('Student C', 2);
INSERT INTO C##MYUSER.STUDENTS (ID, NAME, GROUP_ID) VALUES (NULL, 'Student D', 2);

-- TO_DATE('2023-01-01 00:00:00', 'YYYY-MM-DD HH24:MI:SS')
BEGIN
    RestoreStudents(NULL, 2);
END;
/

SELECT * FROM C##MYUSER.STUDENTS;
SELECT * FROM C##MYUSER.GROUPS;

SELECT * FROM C##MYUSER.STUDENTS_LOG;


DELETE FROM C##MYUSER.STUDENTS WHERE NAME = 'Student A';

INSERT INTO C##MYUSER.STUDENTS (ID, NAME, GROUP_ID) VALUES (1, 'Иван', 1);
INSERT INTO C##MYUSER.STUDENTS (ID, NAME, GROUP_ID) VALUES (5, 'Мария', 3);

-- 6. Триггер для обновления C_VAL в GROUPS
CREATE OR REPLACE TRIGGER update_group_count
AFTER INSERT OR UPDATE OR DELETE ON C##MYUSER.STUDENTS
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        UPDATE C##MYUSER.GROUPS SET C_VAL = C_VAL + 1 WHERE ID = :NEW.GROUP_ID;
    ELSIF UPDATING THEN
        UPDATE C##MYUSER.GROUPS SET C_VAL = C_VAL - 1 WHERE ID = :OLD.GROUP_ID;
        UPDATE C##MYUSER.GROUPS SET C_VAL = C_VAL + 1 WHERE ID = :NEW.GROUP_ID;
    ELSIF DELETING THEN
        UPDATE C##MYUSER.GROUPS SET C_VAL = C_VAL - 1 WHERE ID = :OLD.GROUP_ID;
    END IF;
END;
/

SELECT * FROM c##myuser.GROUPS;
SELECT * FROM c##myuser.STUDENTS;
DELETE FROM c##myuser.students where id = 5;